#version 430 core

//---built-ins---
//in uvec3 gl_NumWorkGroups
//in uvec3 gl_WorkGroupID
//in uvec3 gl_GlobalInvocationID
//in uvec3 gl_LocalInvocationID
//in uint  gl_LocalInvocationIndex


//workgroup parameters
#define NUM_GROUPS_X 16
#define NUM_GROUPS_Y 16

layout(local_size_x = NUM_GROUPS_X, local_size_y = NUM_GROUPS_Y) in;


//coeficients of discretisized poisson equation(coefs both for bound and inner domain)
//it's a cross template
// y
// ^        ____  
// |   ____|_21_|____
// |  |_10_|_11_|_12_|  -- used indices(later will be used for naming appropriate solution values)
// |       |_01_|
// 0------------------>x
//
struct CrossCoefficients
{
	           float c21;
	float c10; float c11; float c12;
	           float c01;
};

layout(std430, binding = 0) buffer equations
{
	CrossCoefficients coefficients[];			
};

//padded solution & function(image2D) + equations coefficients
layout(binding = 0, rgba32f) uniform image2D solution; 
layout(binding = 1, rgba32f) uniform image2D function;


//uniform to know what cell type is updated
#define RED   0
#define BLACK 1
uniform uint uRedOrBlack;


//solution method is chebyshev accelerated SSOR
//relaxation parameter for solving poisson equation
uniform float uOmega;


//one invocation deals with 2x2 square
//one invocation updates two cells(two red or two black cells)
//(0 - start index computed as (2 * x, 2 * y) where x, y are the first components of gl_GlobalInvocationID)
// ___ ___  ___ ___ 
//|___|___||___|___|
//|_0_|___||_0_|___|
// ___ ___  ___ ___ 
//|___|___||___|___|
//|_0_|___||_0_|___|
//
// Ordering is the following:
// ___ ___ 
//|_B_|_R_|
//|_R_|_B_|

//cells' offsets                      Red          Black
const ivec2  FIRST_CELL_OFFSETS[2] = {ivec2(0, 0), ivec2(1, 0)};
const ivec2 SECOND_CELL_OFFSETS[2] = {ivec2(1, 1), ivec2(0, 1)};

//update cell
void redBlackStep(ivec2 indexVec, int indexFlat)
{
	//get equation coefs
	CrossCoefficients equ = coefficients[indexFlat];

	//get solution values for cross update
	vec4 s21 = imageLoad(solution, indexVec + ivec2(+1,  0));
	vec4 s12 = imageLoad(solution, indexVec + ivec2( 0, +1));
	vec4 s11 = imageLoad(solution, indexVec                );
	vec4 s10 = imageLoad(solution, indexVec + ivec2( 0, -1));
	vec4 s01 = imageLoad(solution, indexVec + ivec2(-1,  0));

	//get function value
	vec4 f = imageLoad(function, indexVec);

	//algorithm(accelerated SSOR)
	s11 =               
	                    + equ.c21 * s21
		+ equ.c10 * s10 + equ.c11 * s11 + equ.c12 * s12
	                    + equ.c01 * s01
	                    
	                    + f;

	//store back new value
	imageStore(solution, indexVec, s11);
}

//y(padding)
//^    ____________________________
//|   |_0_|_0_|_0_|_0_|_0_|_0_|_0_|
//|   |_0_|___|___|___|___|___|_0_|
//|   |_0_|___|___|___|___|___|_0_|
//|j+1|_0_|___|___|_x_|___|___|_0_|
//|   |_0_|___|___|___|___|___|_0_|
//|   |_0_|___|___|___|___|___|_0_|
//|   |_0_|_0_|_0_|_0_|_0_|_0_|_0_|
//|                i+1
//0----------------------------------->x
void main()
{
	//extents of work
	ivec2 extents = imageSize(solution); // image is padded 

	//base index counting padding
	ivec2 baseIndexVec = 2 * ivec2(gl_GlobalInvocationID.xy) + ivec2(1, 1);

	//get offsets of updated cell according to current cell type(red or black)
	ivec2  firstCellOffset =  FIRST_CELL_OFFSETS[uRedOrBlack];
	ivec2 secondCellOffset = SECOND_CELL_OFFSETS[uRedOrBlack];

	//first cell update
	ivec2 indexVec  = baseIndexVec + firstCellOffset;
	int   indexFlat = indexVec.y * extents.x + indexVec.x;
	redBlackStep(indexVec, indexFlat);

	//second cell update
	indexVec  = baseIndexVec + secondCellOffset;
	indexFlat = indexVec.y * extents.x + indexVec.x;
	redBlackStep(indexVec, indexFlat);
}