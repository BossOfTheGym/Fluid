#version 450 core

//workgroup parameters
#define LOCAL_SIZE_X 16
#define LOCAL_SIZE_Y 16

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;


//coeficients of discretisized 2D poisson equation(coefs both for bound and inner domain)
//it's a cross template
// y
// ^        ____  
// |   ____|_21_|____
// |  |_10_|_11_|_12_|  -- used indices(later will be used for naming appropriate solution values)
// |       |_01_|
// 0------------------>x
//
struct CrossCoefficients
{
	           float c21;
	float c10; float c11; float c12;
	           float c01;
};

layout(binding = 0, std430) buffer coefficients
{
	CrossCoefficients data[];			
};

//solution & function(image2D) + equations coefficients
layout(binding = 3, std430) buffer boundaryWeights
{
	float data[];
};

//step
uniform vec2 uH;

//discrete approximation of the order O(h^2)
int flattenPadded(ivec2 index, ivec2 extents)
{
	extents += ivec2(2, 2);
	index   += ivec2(1, 1);

	return extents.x * index.y + index.x;
}

int flatten(ivec2 index, ivec2 extents)
{

	return extents.x * index.y + index.x;	
}

void setCoefs(ivec2 index, ivec2 extents, CrossCoefficients value)
{
	coefficients.data[flatten(index, extents)] = value;
}

void setWeights(ivec2 index, ivec2 extents, float value)
{
	boundaryWeights.data[flattenPadded(index, extents)] = value;
}


void main()
{
	ivec2 extents = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
	ivec2 limits  = extents - ivec2(1, 1);

	ivec2 indexVec  = ivec2(gl_GlobalInvocationId);

	//values for initialization
	//function & solution are all zeros
	CrossCoefficients coefs;
	vec4 weight;

	//precompute some coefficients(general)
	float hx = uH.x;
	float hy = uH.y;
	float hxInv = 1.0f / hx;
	float hyInv = 1.0f / hy;
	float hx2 = hx * hx;
	float hy2 = hy * hy;
	float hx2Inv = 1.0f / hx2;
	float hy2Inv = 1.0f / hy2;


	//inner conditions(conditions in inner points od domain)
					    coefs.c21 = hy2Inv;
	coefs.c10 = hx2Inv; coefs.c11 = -2.0f * (hx2Inv + hy2Inv); coefs.c12 = hx2Inv;
	                    coefs.c01 = hy2Inv;

	weight = 1.0f;

	//coeeficients for bounds
	float LRB = hy / (2.0f * hx2); //left-right  bound, common coefficient
	float LUB = hx / (2.0f * hy2); //lower-upper bound, common coefficient

	if(indexVec.y == 0) //lower bound
	{
			             coefs.c21 =  hyInv;
		coefs.c10 = LUB; coefs.c11 = -hyInv - 2.0f * LUB; coefs.c12 = LUB;
		                 coefs.c01 =  0.0f;

		weight = hy / 2.0f;
	}
	else if(indexVec.y == limits.y) //upper bound
	{
			              coefs.c21 =  0.0;
		coefs.c10 = -LUB; coefs.c11 =  hyInv + 2.0f * LUB; coefs.c12 = -LUB;
	    	              coefs.c01 = -hyInv;

	    weight = -hy / 2.0f;
	}
	else if(indexVec.x == 0) // left bound
	{
			             coefs.c21 =  LRB;
		coefs.c10 = 0.0; coefs.c11 = -hxInv - 2.0f * LRB; coefs.c12 = hxInv;
		                 coefs.c01 =  LRB;

	    weight = hx / 2.0f;
	}
	else if(indexVec.x == limits.x) // right bound
	{
			                coefs.c21 = -LRB;
		coefs.c10 = -hxInv; coefs.c11 = hxInv + 2.0f * LRB; coefs.c12 = 0.0;
		                    coefs.c01 = -LRB;

	    weight = -hx / 2.0f;
	}

	//corners
	float CC = hx / hy2; // corner coefficient

	if(indexVec == ivec2(0, 0)) //left lower
	{
			             coefs.c21 =  CC;
		coefs.c10 = 0.0; coefs.c11 = -hxInv - CC; coefs.c12 = hxInv;
		                 coefs.c01 = 0.0;

	    weight = hx / 2.0f;
	}
	if(indexVec == ivec2(limits.x, 0)) // right lower
	{
			                coefs.c21 = -CC;
		coefs.c10 = -hxInv; coefs.c11 = hxInv + CC; coefs.c12 = 0.0;
	                        coefs.c01 = 0.0;	

	    weight = -hx / 2.0f;
	}
	if(indexVec == ivec2(limits.x, limits.y)) // right upper
	{
			                coefs.c21 = 0.0;
		coefs.c10 = -hxInv; coefs.c11 = hxInv + CC; coefs.c12 = 0.0;
		                    coefs.c01 = -CC;

	    weight = -hx / 2.0f;
	}
	if(indexVec == ivec2(0, limits.y)) // left upper
	{
			             coefs.c21 = 0.0;
		coefs.c10 = 0.0; coefs.c11 = -hxInv - CC; coefs.c12 = hxInv;
		                 coefs.c01 = CC;

	    weight = vec4(hx / 2.0f);
	}

	  setCoefs(indexVec, extents, coefs);
	setWeights(indexVec, extents, weight);
}