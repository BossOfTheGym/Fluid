#version 450 core

//workgroup parameters
#define LOCAL_SIZE_X 16
#define LOCAL_SIZE_Y 16

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;


//coeficients of discretisized 2D poisson equation(coefs both for bound and inner domain)
//it's a cross template
// y
// ^        ____  
// |   ____|_21_|____
// |  |_10_|_11_|_12_|  -- used indices(later will be used for naming appropriate solution values)
// |       |_01_|
// 0------------------>x
//
struct CrossCoefficients
{
	           float c21;
	float c10; float c11; float c12;
	           float c01;
};

layout(std430, binding = 0) buffer equations
{
	CrossCoefficients coefficients[];			
};


//solution & function(image2D) + equations coefficients
layout(binding = 0, rgba32f) uniform image2D solution;
layout(binding = 1, rgba32f) uniform image2D function;
layout(binding = 2, rgba32f) uniform image2D weights;

//step
uniform vec2 uH;

//discrete approximation of the order O(h^2)
void main()
{
	ivec2 extents = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
	ivec2 limits  = extents - ivec2(1, 1);

	ivec2 indexVec  = ivec2(gl_GlobalInvocationId);
	ivec2 indexFlat = indexVec.y * extents.x + indexVec.x;

	//values for initialization
	//function & solution are all zeros
	CrossCoefficients coefs;
	vec4 weigth;

	//precompute some coefficients(general)
	float hx = uH.x;
	float hy = uH.y;
	float hxInv = 1.0f / hx;
	float hyInv = 1.0f / hy;
	float hx2 = hx * hx;
	float hy2 = hy * hy;
	float hx2Inv = 1.0f / hx2;
	float hy2Inv = 1.0f / hy2;


	//inner conditions(conditions in inner points od domain)
					    coefs.c21 = hy2Inv;
	coefs.c10 = hx2Inv; coefs.c11 = -2.0f * (hx2Inv + hy2Inv); coefs.c12 = hx2Inv;
	                    coefs.c01 = hy2Inv;

	weight = vec4(1.0f);

	//coeeficients for bounds
	float LRB = hy / (2.0f * hx2); //left-right  bound, common coefficient
	float LUB = hx / (2.0f * hy2); //lower-upper bound, common coefficient

	if(indexVec.y == 0) //lower bound
	{
			             coefs.c21 =  hyInv;
		coefs.c10 = LUB; coefs.c11 = -hyInv - 2.0f * LUB; coefs.c12 = LUB;
		                 coefs.c01 =  0.0f;

		weight = vec4(hy / 2.0f);
	}
	else if(indexVec.y == limits.y) //upper bound
	{
			              coefs.c21 =  0.0;
		coefs.c10 = -LUB; coefs.c11 =  hyInv + 2.0f * LUB; coefs.c12 = -LUB;
	    	              coefs.c01 = -hyInv;

	    weight = vec4(-hy / 2.0f);
	}
	else if(indexVec.x == 0) // left bound
	{
			             coefs.c21 =  LRB;
		coefs.c10 = 0.0; coefs.c11 = -hxInv - 2.0f * LRB; coefs.c12 = hxInv;
		                 coefs.c01 =  LRB;

	    weight = vec4(hx / 2.0f);
	}
	else if(indexVec.x == limits.x) // right bound
	{
			                coefs.c21 = -LRB;
		coefs.c10 = -hxInv; coefs.c11 = hxInv + 2.0f * LRB; coefs.c12 = 0.0;
		                    coefs.c01 = -LRB;

	    weight = vec4(-hx / 2.0f);
	}

	//corners
	float CC = hx / hy2; // corner coefficient

	if(indexVec == ivec2(0, 0)) //left lower
	{
			             coefs.c21 =  CC;
		coefs.c10 = 0.0; coefs.c11 = -hxInv - CC; coefs.c12 = hxInv;
		                 coefs.c01 = 0.0;

	    weight = vec4(hx / 2.0f);
	}
	if(indexVec == ivec2(limits.x, 0)) // right lower
	{
			                coefs.c21 = -CC;
		coefs.c10 = -hxInv; coefs.c11 = hxInv + CC; coefs.c12 = 0.0;
	                        coefs.c01 = 0.0;	

	    weight = vec4(-hx / 2.0f);
	}
	if(indexVec == ivec2(limits.x, limits.y)) // right upper
	{
			                coefs.c21 = 0.0;
		coefs.c10 = -hxInv; coefs.c11 = hxInv + CC; coefs.c12 = 0.0;
		                    coefs.c01 = -CC;

	    weight = vec4(-hx / 2.0f);
	}
	if(indexVec == ivec2(0, limits.y)) // left upper
	{
			             coefs.c21 = 0.0;
		coefs.c10 = 0.0; coefs.c11 = -hxInv - CC; coefs.c12 = hxInv;
		                 coefs.c01 = CC;

	    weight = vec4(hx / 2.0f);
	}

	coefficients[indexFlat] = coefs;
	imageStore(solution, vec4(0.0f), indexVec);
	imageStore(function, vec4(0.0f), indexVec);
	imageStore(weights , weigth    , indexVec);

	memoryBarrierImage();
	memoryBarrierBuffer();
}